# Práctica 2 / Ejercicio 4

**a)** $\mathcal{L}^c$, el complemento de $\mathcal{L}$.

Dado un AFD $M = (Q, \Sigma, \delta, q_0, F)$, primero nos aseguramos que esté completo. Tienen que estar todos los estados y todas las transiciones para cada símbolo del alfabeto (quizás haya que agregar un estado trampa si no lo tiene).

Luego, podemos construir otro AFD $M' = (Q, \Sigma, \delta, q_0, F')$ donde $F' = Q \setminus F$.

Al invertir los estados finales, las cadenas que acepta $M$ no se aceptan en $M'$, y viceversa, logrando así que $\mathcal{L}(M') = \mathcal{L}^c$.

---

**b)** $\mathcal{L}^\ast$, la clausura de Kleene $\mathcal{L}$.

Dado un autómata finito $M = (Q, \Sigma, \delta, q_0, F)$ lo extendemos para construir otro AFND- $\lambda$ $M' = (Q \cup \{ q_I,q_F \}, \Sigma, \delta', q_I, \{ q_F \})$ que "encapsula" a $M$.

- Agregamos un estado inicial $q_I$ que se conecta con una transición $\lambda$ al estado inicial $q_0$ de $M$.
- Agregamos un estado final $q_F$ que se conecta con una transición $\lambda$ desde todos los estados finales de $M$.
- El nuevo estado inicial $q_I$ es también final para aceptar la cadena vacía.
- Hay una transición $\lambda$ desde $q_F$ hacia $q_I$ que en esencia permite repetir las cadenas que acepta $M$ una cantidad arbitraria de veces, generando así la clausura de Kleene.

Indistintamente del determinismo de $M$, el nuevo autómata $M'$ resulta un AFND- $\lambda$.

<img src="./assets/ej04b.png" width="420" />

*Versión alternativa sin agregar estados nuevos*

- Se mantiene el estado inicial.
- Se agregan transiciones $\lambda$ desde todos los estados finales hacia el estado inicial.
- Si $M$ originalmente no aceptaba la cadena vacía, el estado inicial pasa a ser también un estado final.

---

**c)** $\mathcal{L}^r$, la reversa de $\mathcal{L}$.

Dado un autómata finito $M = (Q, \Sigma, \delta, q_0, F)$ lo extendemos para construir otro AFND- $\lambda$ $M' = (Q \cup \{ q_I,q_F \}, \Sigma, \delta', q_I, \{ q_F \})$ que invierte el sentido de todas las transiciones de $M$.

- Se invierte el sentido de todas las transiciones de $M$.
- Agregamos un estado inicial $q_I$ que se conecta con una transición $\lambda$ a todos los estados finales de $M$.
- Agregamos un estado final $q_F$ que se conecta con una transición $\lambda$ desde el estado inicial $q_0$ de $M$.

Indistintamente del determinismo de $M$, el nuevo autómata $M'$ resulta un AFND- $\lambda$.

<img src="./assets/ej04c.png" width="420" />

---

**d)** $\text{Ini}(\mathcal{L}) = \{ \alpha \mid \exists \beta \text{ tal que } \alpha\beta \in \mathcal{L} \}$, los prefijos de $\mathcal{L}$.

Dado un autómata finito $M = (Q, \Sigma, \delta, q_0, F)$, construimos el autómata $M' = (Q, \Sigma, \delta, q_0, F')$ tal que $F'$ son todos los estados de $Q$ que pertenecen a algún camino de aceptación, es decir, están en algún camino entre $q_0$ y algún $q_f \in F$.

En esencia permitimos quedarnos "a mitad de camino" entre $q_0$ y algún $q_f \in F$, aceptando así los prefijos.

El autómata $M'$ preserva el determinismo de $M$.

---

**e)** $\text{Fin}(\mathcal{L}) = \{ \alpha \mid \exists \gamma \text{ tal que } \gamma\alpha \in \mathcal{L} \}$, los sufijos de $\mathcal{L}$.

Dado un autómata finito $M = (Q, \Sigma, \delta, q_0, F)$, construimos un AFND- $\lambda$ $M' = (Q, \Sigma, \delta', q_0, F)$ donde extendemos $\delta'$ agregando transiciones $\lambda$ desde el estado inicial $q_0$ hacia todos los estados de $Q$ que pertenecen a algún camino de aceptación, es decir, están en algún camino entre $q_0$ y algún $q_f \in F$.

En esencia permitimos comenzar a consumir una cadena "a mitad de camino" entre $q_0$ y algún $q_f \in F$, aceptando así los sufijos.

---

**f)** $\text{Sub}(\mathcal{L}) = \{ \alpha \mid \exists (\gamma, \beta) \text{ tales que } \gamma\alpha\beta \in \mathcal{L} \}$, las subcadenas de $\mathcal{L}$.

Dado un autómata finito $M = (Q, \Sigma, \delta, q_0, F)$, construimos un AFND- $\lambda$ $M'$ con los procedimientos de los incisos d) y e). Al combinar prefijos y sufijos obtenemos las subcadenas.

---

**g)** $\text{Max}(\mathcal{L}) = \{ \alpha \in \mathcal{L} \mid \forall \omega \in \Sigma^+, \alpha\omega \notin \mathcal{L} \}$, las cadenas maximales de $\mathcal{L}$.

Dado un autómata finito $M = (Q, \Sigma, \delta, q_0, F)$, construimos otro autómata con el mismo determinismo $M' = (Q, \Sigma, \delta, q_0, F')$ donde $F' \subseteq F$ es el subconjunto de estados finales de $M$ tales que no exista un camino de aceptación desde ningún $q_f \in F'$. Es decir, para todo camino de aceptación desde $q_0$ que pasa por varios estados finales $q_{f_1}, \dots, q_{f_k}$, nos quedamos únicamente con $q_{f_k}$ como estado final.

La idea es que sacamos todos los estados finales desde donde podemos aceptar cadenas más largas. Si llegamos a un estado final, no deberíamos poder aceptar ninguna otra cadena más larga, ya que solo nos interesan las cadenas maximales.

Observación: Si $M$ acepta cadenas arbitrariamente largas, entonces hay estados finales dentro de algún ciclo. Con el procedimiento anterior, ese estado ya no sería final.

---

**h)** $\text{Min}(\mathcal{L}) = \{ \alpha \in \mathcal{L} \mid \text{ningún prefijo propio de } \alpha \text{ pertenece a } \mathcal{L} \}$, las cadenas minimales de $\mathcal{L}$. Es decir, $\text{Min}(\mathcal{L}) = \{ \alpha \in \mathcal{L} \mid \not\exists (\omega_1, \omega_2) \text{ tales que } \alpha = \omega_1\omega_2 \land \omega_1 \in \mathcal{L} \land \omega_2 \neq \lambda \}$.

Dado un AFD $M = (Q, \Sigma, \delta, q_0, F)$, construimos otro AFD $M' = (Q, \Sigma, \delta', q_0, F')$ donde $F' \subseteq F$ es el subconjunto de estados finales $q_f$ de $M$ tales que no exista otro estado final entre $q_0$ y $q_f$. Es decir, para todo camino de aceptación desde $q_0$ que pasa por varios estados finales $q_{f_1}, \dots, q_{f_k}$, nos quedamos únicamente con $q_{f_1}$ como estado final (el primero).

Además, en $\delta'$ quitamos todas las transiciones desde cualquiera de los nuevos estados finales en $F'$. Esto es especialmente necesario cuando en $M$ hay estados finales que pertenecen a un ciclo (pensar en el AFD que reconoce $a^+$).



La idea es que apenas llegamos a un estado final, aceptamos esa cadena y desde ahí en más no vamos a aceptar ninguna otra cadena. Ya que si lo haríamos, esa segunda cadena que aceptamos tiene un prefijo propio (la primer cadena que aceptamos) que es parte del lenguaje.

Necesitamos pedir que $M$ sea AFD para garantizar que no exista otro camino completamente distinto que termine aceptando prefijos de las cadenas minimales que aceptamos.

---

**i)** $\mathcal{L}_T = \{ \alpha \in \Sigma^\ast \mid \exists (\omega_1 \in \mathcal{L}, \omega_2 \in \Sigma^\ast) \text{ tales que } \alpha = \omega_1\omega_2 \} = \mathcal{L}.\Sigma^\ast$.

Dado un autómata finito $M = (Q, \Sigma, \delta, q_0, F)$, construimos un AFND- $\lambda$ $M' = (Q, \Sigma, \delta', q_0, F)$ donde extendemos $\delta'$ agregando transiciones desde todos los estados finales hacia ellos mismos para todos los símbolos del alfabeto.
